apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-scripts
  namespace: swifteats
data:
  backup.sh: |
    #!/bin/bash
    set -e
    
    # Configuration
    BACKUP_TYPE=${BACKUP_TYPE:-full}
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_DIR="/backups"
    POSTGRES_HOST="postgres-primary-service"
    POSTGRES_PORT="5432"
    POSTGRES_DB="swifteats"
    POSTGRES_USER="postgres"
    
    # Create backup directory
    mkdir -p ${BACKUP_DIR}/${BACKUP_TYPE}
    
    # Set backup filename
    BACKUP_FILE="${BACKUP_DIR}/${BACKUP_TYPE}/swifteats_${BACKUP_TYPE}_${TIMESTAMP}.sql"
    
    echo "Starting ${BACKUP_TYPE} backup at $(date)"
    echo "Backup file: ${BACKUP_FILE}"
    
    # Perform backup based on type
    case ${BACKUP_TYPE} in
      "full")
        echo "Performing full backup..."
        PGPASSWORD=${POSTGRES_PASSWORD} pg_dump \
          -h ${POSTGRES_HOST} \
          -p ${POSTGRES_PORT} \
          -U ${POSTGRES_USER} \
          -d ${POSTGRES_DB} \
          --verbose \
          --no-password \
          --compress=9 \
          --format=custom \
          --file="${BACKUP_FILE}"
        ;;
      "schema")
        echo "Performing schema-only backup..."
        PGPASSWORD=${POSTGRES_PASSWORD} pg_dump \
          -h ${POSTGRES_HOST} \
          -p ${POSTGRES_PORT} \
          -U ${POSTGRES_USER} \
          -d ${POSTGRES_DB} \
          --verbose \
          --no-password \
          --schema-only \
          --compress=9 \
          --format=custom \
          --file="${BACKUP_FILE}"
        ;;
      "data")
        echo "Performing data-only backup..."
        PGPASSWORD=${POSTGRES_PASSWORD} pg_dump \
          -h ${POSTGRES_HOST} \
          -p ${POSTGRES_PORT} \
          -U ${POSTGRES_USER} \
          -d ${POSTGRES_DB} \
          --verbose \
          --no-password \
          --data-only \
          --compress=9 \
          --format=custom \
          --file="${BACKUP_FILE}"
        ;;
    esac
    
    # Calculate checksum
    CHECKSUM=$(sha256sum "${BACKUP_FILE}" | cut -d' ' -f1)
    echo "${CHECKSUM}" > "${BACKUP_FILE}.sha256"
    
    # Get backup size
    BACKUP_SIZE=$(stat -f%z "${BACKUP_FILE}" 2>/dev/null || stat -c%s "${BACKUP_FILE}")
    
    # Create metadata file
    cat > "${BACKUP_FILE}.metadata" << EOF
    {
      "backup_id": "$(basename ${BACKUP_FILE} .sql)",
      "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
      "type": "${BACKUP_TYPE}",
      "size": ${BACKUP_SIZE},
      "checksum": "${CHECKSUM}",
      "location": "${BACKUP_FILE}",
      "database": "${POSTGRES_DB}",
      "host": "${POSTGRES_HOST}",
      "status": "completed"
    }
    EOF
    
    echo "Backup completed successfully at $(date)"
    echo "Backup size: $(numfmt --to=iec ${BACKUP_SIZE})"
    echo "Checksum: ${CHECKSUM}"
    
    # Upload to remote storage if configured
    if [ "${REMOTE_STORAGE_ENABLED}" = "true" ]; then
      echo "Uploading backup to remote storage..."
      case ${REMOTE_STORAGE_PROVIDER} in
        "aws")
          aws s3 cp "${BACKUP_FILE}" "s3://${REMOTE_STORAGE_BUCKET}/backups/${BACKUP_TYPE}/"
          aws s3 cp "${BACKUP_FILE}.sha256" "s3://${REMOTE_STORAGE_BUCKET}/backups/${BACKUP_TYPE}/"
          aws s3 cp "${BACKUP_FILE}.metadata" "s3://${REMOTE_STORAGE_BUCKET}/backups/${BACKUP_TYPE}/"
          ;;
        "gcp")
          gsutil cp "${BACKUP_FILE}" "gs://${REMOTE_STORAGE_BUCKET}/backups/${BACKUP_TYPE}/"
          gsutil cp "${BACKUP_FILE}.sha256" "gs://${REMOTE_STORAGE_BUCKET}/backups/${BACKUP_TYPE}/"
          gsutil cp "${BACKUP_FILE}.metadata" "gs://${REMOTE_STORAGE_BUCKET}/backups/${BACKUP_TYPE}/"
          ;;
      esac
      echo "Remote upload completed"
    fi
    
    # Cleanup old backups
    if [ "${CLEANUP_ENABLED}" = "true" ]; then
      echo "Cleaning up old backups..."
      find ${BACKUP_DIR}/${BACKUP_TYPE} -name "*.sql" -mtime +${RETENTION_DAYS:-30} -delete
      find ${BACKUP_DIR}/${BACKUP_TYPE} -name "*.sha256" -mtime +${RETENTION_DAYS:-30} -delete
      find ${BACKUP_DIR}/${BACKUP_TYPE} -name "*.metadata" -mtime +${RETENTION_DAYS:-30} -delete
      echo "Cleanup completed"
    fi

  verify.sh: |
    #!/bin/bash
    set -e
    
    BACKUP_FILE=$1
    
    if [ -z "${BACKUP_FILE}" ]; then
      echo "Usage: $0 <backup_file>"
      exit 1
    fi
    
    if [ ! -f "${BACKUP_FILE}" ]; then
      echo "Backup file not found: ${BACKUP_FILE}"
      exit 1
    fi
    
    echo "Verifying backup: ${BACKUP_FILE}"
    
    # Verify checksum
    if [ -f "${BACKUP_FILE}.sha256" ]; then
      echo "Verifying checksum..."
      EXPECTED_CHECKSUM=$(cat "${BACKUP_FILE}.sha256")
      ACTUAL_CHECKSUM=$(sha256sum "${BACKUP_FILE}" | cut -d' ' -f1)
      
      if [ "${EXPECTED_CHECKSUM}" = "${ACTUAL_CHECKSUM}" ]; then
        echo "✓ Checksum verification passed"
      else
        echo "✗ Checksum verification failed"
        echo "Expected: ${EXPECTED_CHECKSUM}"
        echo "Actual: ${ACTUAL_CHECKSUM}"
        exit 1
      fi
    else
      echo "⚠ No checksum file found, skipping checksum verification"
    fi
    
    # Verify backup format
    echo "Verifying backup format..."
    if pg_restore --list "${BACKUP_FILE}" > /dev/null 2>&1; then
      echo "✓ Backup format verification passed"
    else
      echo "✗ Backup format verification failed"
      exit 1
    fi
    
    echo "Backup verification completed successfully"

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: backup-storage-pvc
  namespace: swifteats
spec:
  accessModes:
    - ReadWriteMany
  storageClassName: nfs
  resources:
    requests:
      storage: 500Gi

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-full-backup
  namespace: swifteats
  labels:
    app: postgres-backup
    type: full
spec:
  schedule: "0 2 * * 0" # Weekly on Sunday at 2 AM
  timeZone: "UTC"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: postgres-backup
            type: full
        spec:
          restartPolicy: OnFailure
          containers:
          - name: postgres-backup
            image: postgres:15-alpine
            command:
            - /bin/bash
            - /scripts/backup.sh
            env:
            - name: BACKUP_TYPE
              value: "full"
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-primary-secret
                  key: postgres-password
            - name: REMOTE_STORAGE_ENABLED
              value: "false"
            - name: CLEANUP_ENABLED
              value: "true"
            - name: RETENTION_DAYS
              value: "30"
            volumeMounts:
            - name: backup-storage
              mountPath: /backups
            - name: backup-scripts
              mountPath: /scripts
            resources:
              requests:
                memory: "256Mi"
                cpu: "200m"
              limits:
                memory: "1Gi"
                cpu: "1000m"
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: backup-storage-pvc
          - name: backup-scripts
            configMap:
              name: backup-scripts
              defaultMode: 0755

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-incremental-backup
  namespace: swifteats
  labels:
    app: postgres-backup
    type: incremental
spec:
  schedule: "0 2 * * 1-6" # Daily Monday to Saturday at 2 AM
  timeZone: "UTC"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: postgres-backup
            type: incremental
        spec:
          restartPolicy: OnFailure
          containers:
          - name: postgres-backup
            image: postgres:15-alpine
            command:
            - /bin/bash
            - /scripts/backup.sh
            env:
            - name: BACKUP_TYPE
              value: "data"
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-primary-secret
                  key: postgres-password
            - name: REMOTE_STORAGE_ENABLED
              value: "false"
            - name: CLEANUP_ENABLED
              value: "true"
            - name: RETENTION_DAYS
              value: "7"
            volumeMounts:
            - name: backup-storage
              mountPath: /backups
            - name: backup-scripts
              mountPath: /scripts
            resources:
              requests:
                memory: "256Mi"
                cpu: "200m"
              limits:
                memory: "1Gi"
                cpu: "1000m"
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: backup-storage-pvc
          - name: backup-scripts
            configMap:
              name: backup-scripts
              defaultMode: 0755

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-backup-verification
  namespace: swifteats
  labels:
    app: postgres-backup
    type: verification
spec:
  schedule: "0 4 * * *" # Daily at 4 AM
  timeZone: "UTC"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: postgres-backup
            type: verification
        spec:
          restartPolicy: OnFailure
          containers:
          - name: backup-verification
            image: postgres:15-alpine
            command:
            - /bin/bash
            - -c
            - |
              echo "Starting backup verification..."
              
              # Find latest backups
              LATEST_FULL=$(find /backups/full -name "*.sql" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2)
              LATEST_DATA=$(find /backups/data -name "*.sql" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2)
              
              # Verify latest full backup
              if [ -n "${LATEST_FULL}" ]; then
                echo "Verifying latest full backup: ${LATEST_FULL}"
                /scripts/verify.sh "${LATEST_FULL}"
              else
                echo "No full backup found to verify"
              fi
              
              # Verify latest incremental backup
              if [ -n "${LATEST_DATA}" ]; then
                echo "Verifying latest incremental backup: ${LATEST_DATA}"
                /scripts/verify.sh "${LATEST_DATA}"
              else
                echo "No incremental backup found to verify"
              fi
              
              echo "Backup verification completed"
            volumeMounts:
            - name: backup-storage
              mountPath: /backups
            - name: backup-scripts
              mountPath: /scripts
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "512Mi"
                cpu: "500m"
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: backup-storage-pvc
          - name: backup-scripts
            configMap:
              name: backup-scripts
              defaultMode: 0755
